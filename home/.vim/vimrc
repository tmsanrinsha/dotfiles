set encoding=utf-8
scriptencoding utf-8
" vimrcでマルチバイト文字を使うためにscriptencodingを設定する。
" この時、set encodingはscriptencodingより先に宣言する。
" vimrcやgvimrcがあると自動的にset nocompatibleになるので、set nocompatibleは書かない。
" 書くとオプションhistoryが初期化され、履歴が削除されてしまう。
"   vim -u <vimの設定ファイル>
" のように指定して起動すると、set nocompatibleにならないので、
"   vim -u <vimの設定ファイル> -N
" のように-Nオプションを付けて起動する
" cf. vimrcアンチパターン - rbtnn雑記
"     http://rbtnn.hateblo.jp/entry/2014/11/30/174749

" 初期設定 {{{1
" ============================================================================
if empty($XDG_CACHE_HOME)
    let $XDG_CACHE_HOME = $HOME . '/.cache'
endif
let $VIM_CACHE_DIR = expand('$XDG_CACHE_HOME/vim')
if !isdirectory($VIM_CACHE_DIR)
    call mkdir($VIM_CACHE_DIR, 'p')
endif

let $VIMRC_DIR = $HOME.'/.vim/rc'

if has('win32')
    set runtimepath&
    set runtimepath^=$HOME/.vim
    set runtimepath+=$HOME/.vim/after
    cd ~
endif

if empty($SRC_ROOT)
    let $SRC_ROOT = $HOME . '/src'
endif

let s:dotfiles_home = $SRC_ROOT.'/github.com/tmsanrinsha/dotfiles/home'
let g:dein_dir = expand('$VIM_CACHE_DIR/dein')

" vimrc全体で使うaugroup {{{1
" ============================================================================
" http://rhysd.hatenablog.com/entry/2012/12/19/001145
" autocmd!の回数を減らすことでVimの起動を早くする
" ネームスペースを別にしたい場合は別途augroupを作る
augroup MyVimrc
    autocmd!
augroup END

" function {{{1
" ============================================================================
function! SourceRc(path) " {{{
    if filereadable(expand('$VIMRC_DIR/'.a:path))
        execute 'source $VIMRC_DIR/'.a:path
    endif
endfunction " }}}
function! MyHasPatch(str) " {{{
    if has('patch-7.4.237')
        return has(a:str)
    else
        let l:patches =  split(matchstr(a:str, '\v(\d|\.)+'), '\.')
        return v:version >  l:patches[0] . 0 . l:patches[1] ||
            \  v:version == l:patches[0] . 0 . l:patches[1] && has('patch' . l:patches[2])
    endif
endfunction " }}}
function! MyIsRuning(str) " {{{
    if executable('pgrep')
        return system('pgrep '.a:str) || 0
    endif
    return 0
endfunction " }}}
"" バッファ名nameを持つウィンドウに移動する {{{
function! GotoWin(name)
    let l:nr = bufwinnr(a:name)
    if l:nr > 0
        execute l:nr . 'wincmd w'
    endif
    return l:nr
endfunction " }}}
function! IsInstalled(plugin) " {{{
    " NeoBundleLazyを使うと最初はruntimepathに含まれないため、
    " runtimepathのチェックでプラグインがインストールされているかをチェックできない
    " neobundle#is_installedを直接使うとneobundleがない場合にエラーが出るので確認
    if exists('*dein#tap')
        return dein#tap(a:plugin)
    elseif exists('*neobundle#is_installed')
        return neobundle#is_installed(a:plugin)
    else
        " runtimepathにあるか
        " http://yomi322.hateblo.jp/entry/2012/06/20/225559
        " return !empty(globpath(&runtimepath, 'plugin/'   . a:plugin . '.vim'))
        " \   || !empty(globpath(&runtimepath, 'autoload/' . a:plugin . '.vim'))
        " \   || !empty(globpath(&runtimepath, 'colors/'   . a:plugin . '.vim'))
        return match(&runtimepath, a:plugin) >= 0
    endif
endfunction " }}}
function! GetBufferDir() abort " {{{2
    if exists('b:vimfiler.current_dir')
        return b:vimfiler.current_dir
    else
        let l:buffer_dir = expand('%:p:h')
        return isdirectory(l:buffer_dir) ? l:buffer_dir : ''
    endif
endfunction

function! GetProjectDir() abort " {{{2
    let l:buffer_dir = GetBufferDir()

    let l:project_dir = vital#of('vital').import('Prelude').path2project_directory(l:buffer_dir, 1)
    if empty(l:project_dir) && exists('g:project_dir_pattern')
        let l:project_dir = matchstr(l:buffer_dir, g:project_dir_pattern)
    endif

    if empty(l:project_dir)
        return l:buffer_dir
    else
        return l:project_dir
    endif
    " windowsでドライブのC:をC\:に変更する必要がある
    " let l:project_dir = escape(l:project_dir, ':')
endfunction

function! GetPassword() abort " {{{2
    if !exists('g:password')
        let g:password = inputsecret('password: ')
    endif
    return g:password
endfunction

command! Makelink call s:makelink() " {{{2
function! s:makelink() abort
    let l:real_path = expand('%:p')
    let l:symlink_path = substitute(l:real_path, '.*/home', $HOME, '')
    call system('ln -s ' . shellescape(l:real_path) . ' ' . shellescape(l:symlink_path))
endfunction

" FixSpaces {{{2
" original
" [ntpeters/vim-better-whitespace: Better whitespace highlighting for Vim](https://github.com/ntpeters/vim-better-whitespace)
" Removes all extraneous whitespace in the file
command! -range=% FixSpaces call <SID>fix_spaces(<line1>, <line2>)

function! s:fix_spaces(line1, line2)
    " Save the current search and cursor position
    let _s=@/
    let l = line('.')
    let c = col('.')

    " Trim trailing spaces
    silent! execute ':' . a:line1 . ',' . a:line2 . 's/\s\+$//e'

    " Replace unicode spaces to normal space
    silent! execute ':' . a:line1 . ',' . a:line2 . 's/\%u00A0\|\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000/ /ge'

    " Restore the saved search and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" from以下でファイルの保存したら、to以下にディレクトリ構成を保ってコピーする {{{2
" ----------------------------------------------------------------------------
function! SetAutocmdSyncSaveDir(sync_save_dir_list) abort
    for sync_save_dir in a:sync_save_dir_list
        if len(glob(sync_save_dir['glob'])) == 0
            echoerr 'no match glob'
        endif

        execute 'autocmd MyVimrc BufWritePost ' . sync_save_dir['glob']
        \   . ' call s:syncSaveDir("' . sync_save_dir['from'] . '", "' . sync_save_dir['to'] . '")'
    endfor
endfunction

function! s:syncSaveDir(from, to)
    let l:current_file = expand('%:p')
    " カレントファイルのフルパスのfrom部分をtoに置換する。
    " バックスラッシュをエスケープする必要あり
    let l:target_file = substitute(l:current_file, escape(a:from, '\'), a:to , '')
    let l:target_dir = fnamemodify(l:target_file, ':h')

    if !isdirectory(l:target_dir)
        call mkdir(l:target_dir, 'p')
    endif

    call writefile(readfile(l:current_file, 'b'), l:target_file, 'b')
endfunction

" Call a script local function. {{{2
" ----------------------------------
" [スクリプトローカルな関数を手軽に呼び出す - 永遠に未完成](http://thinca.hatenablog.com/entry/20111228/1325077104)
" Usage:
" - S('local_func')
"   -> call s:local_func() in current file.
" - S('plugin/hoge.vim:local_func', 'string', 10)
"   -> call s:local_func('string', 10) in *plugin/hoge.vim.
" - S('plugin/hoge:local_func("string", 10)')
"   -> call s:local_func("string", 10) in *plugin/hoge(.vim)?.
function! S(f, ...)
  let [file, func] =a:f =~# ':' ?  split(a:f, ':') : [expand('%:p'), a:f]
  let fname = matchstr(func, '^\w*')

  " Get sourced scripts.
  redir =>slist
  silent scriptnames
  redir END

  let filepat = '\V' . substitute(file, '\\', '/', 'g') . '\v%(\.vim)?$'
  for s in split(slist, "\n")
    let p = matchlist(s, '^\s*\(\d\+\):\s*\(.*\)$')
    if empty(p)
      continue
    endif
    let [nr, sfile] = p[1 : 2]
    let sfile = fnamemodify(sfile, ':p:gs?\\?/?')
    if sfile =~# filepat &&
    \    exists(printf("*\<SNR>%d_%s", nr, fname))
      let cfunc = printf("\<SNR>%d_%s", nr, func)
      break
    endif
  endfor

  if !exists('nr')
    echoerr 'Not sourced: ' . file
    return
  elseif !exists('cfunc')
    let file = fnamemodify(file, ':p')
    echoerr printf(
    \    'File found, but function is not defined: %s: %s()', file, fname)
    return
  endif

  return 0 <= match(func, '^\w*\s*(.*)\s*$')
  \      ? eval(cfunc) : call(cfunc, a:000)
endfunction

" 1}}}

if has('mac') && has('kaoriya')
    set runtimepath-=$VIM/plugins/vimproc
endif

call SourceRc('local_pre.vim')

" 基本設定 {{{1
" ============================================================================
" 現在のモードを表示
set showmode
" コマンドを表示
set showcmd
" コマンドラインの高さを2行にする
set cmdheight=2
" 行番号を表示する
set number
" 1行が長い場合でも表示
set display=lastline
" set ruler
" 閉じ括弧が入力されたとき、対応する開き括弧にわずかの間ジャンプする
set showmatch
" マッチを表示する時間を0.1秒にする
set matchtime=1
" set matchpairs+=<:>
" 7.3.769からmatchpairsにマルチバイト文字が使える
if MyHasPatch('patch-7.3.769')
    set matchpairs+=「:」,『:』,（:）,【:】,《:》,〈:〉,［:］,‘:’,“:”
endif

" %の拡張する。%で開始タグ、終了タグを移動、ifとendifを移動など
runtime macros/matchit.vim

" ビジュアルベルにして、設定を空にすることで、ビープ音もビジュアルベルも無効化
set visualbell t_vt=

" CTRL-AやCTRL-Xを使った時の文字の増減の設定
" alpha アルファベットの増減
" octal 8進数の増減
" hex   16進数の増減
" * アルファベットは増減させない
" * 0で始まる数字列を8進数とみなさず、10進数として増減させる。
" * 10進数と16進数を増減させる。
set nrformats=hex

"変更中のファイルでも、保存しないで他のファイルを表示
set hidden

set shellslash

" macに最初から入っているvimはセキュリティの問題からシステムのvimrcでset modelines=0している。
" http://unix.stackexchange.com/questions/19875/setting-vim-filetype-with-modeline-not-working-as-expected
" この問題は7.0.234と7.0.235のパッチで修正された
" https://bugzilla.redhat.com/show_bug.cgi?id=cve-2007-2438
if MyHasPatch('patch-7.0.234') && MyHasPatch('patch-7.0.235')
    set modelines&
else
    set modelines=0
endif

" マウスを使えるようにする
" altやoptionを押しながら、マウスを使うと、set mouseを設定しない時の動きになる。
set mouse=a

" cursor {{{1
" ============================================================================
" 挿入モードでの <BS>, <Del>, CTRL-W, CTRL-U の働きの設定
" indent  autoindent を超えてバックスペースを働かせる
" eol     改行を超えてバックスペースを働かせる (行を連結する)
" start   挿入区間の始めでバックスペースを働かせるが CTRL-W と CTRL-U は
"         挿入区間の始めでいったん止まる
set backspace=indent,eol,start

" カーソルを行頭、行末で止まらないようにする。
set whichwrap&
" set whichwrap=b,s,h,l,<,>,[,],~
" 矩形選択でカーソル位置の制限を解除
set virtualedit=block

" encode, fileformat {{{1
" ============================================================================
" 文字コード
" set encoding=utf-8 上で設定
" カレントバッファのファイルの文字エンコーディングをUTF-8にする。新規にファイルを作った時などに影響する
" setにするとvimrcをリロードした時、バッファのfileencodingを変更してしまうのでsetglobalにする
" :h setglobal
setglobal fileencoding=utf-8

" ファイルの読み込み時に文字エンコーディングを判定する順番
" kaoriya版ではguess_encodeというものがあるので、それを使う
if has('guess_encode')
    set fileencodings=guess,ucs-boms,utf-8,euc-jp,cp932
else
    set fileencodings=ucs-boms,utf-8,euc-jp,cp932
endif
" Vimテクニックバイブル「2-7ファイルの文字コードを変換する」に書いてあるfileencodings。
" ただし2つあるeuc-jpの2番目を消した
" if has("win32")
"     set fileencodings=iso-2222-jp-3,iso-2022-jp,euc-jisx0213,euc-jp,utf-8,ucs-bom,eucjp-ms,cp932
" endif


" エンコーディングを指定して開き直す
command! EncCp932     edit ++enc=cp932
command! EncEucjp     edit ++enc=euc-jp
command! EncIso2022jp edit ++enc=iso-2022-jp
command! EncUtf8      edit ++enc=utf-8
command! EncLatin1    edit ++enc=latin1
" alias
command! EncJis  EncIso2022jp
command! EncSjis EncCp932

" 改行コードの設定
set fileformat=unix
" 改行コードを判定する順番
set fileformats=unix,dos,mac
" 改行コードを指定して開き直すには
"  :e ++ff=dos
" などとする

" 最後に改行が無いテキストファイルに改行を付加しない
if exists('&fixeol')
    set nofixeol
endif

"□や○の文字があってもカーソル位置がずれないようにする
" singleに設定しておいたほうがいい場合もあるかも
set ambiwidth=double

command! DecodeUnicode %s/\\u\([0-9a-fA-Z]\{4}\|[0-9a-zA-Z]\{2}\)/\=nr2char(eval("0x".submatch(1)),1)/g

" tab, indent {{{1
" ============================================================================
" 挿入モードで<Tab>を押したときにスペースに展開する。タブそのものを使いたいときはコメントアウト
set expandtab
" 画面上でタブ文字が占める幅
set tabstop=4

try
    " <Tab>を挿入したり、<BS>を使った時の幅
    " -1に設定するとtabstopの値と同じにする
    " <BS>を使った時に1スペース削除したい場合はコメントアウト
    set softtabstop=-1
    " 自動インデントやコマンド<と>などに使われる空白の数
    " 0の場合はtabstopと同じ値
    set shiftwidth=0
catch /E487/
    let &softtabstop = &tabstop
    let &shiftwidth = &tabstop
endtry

" コマンド<や>でインデントする際に'shiftwidth'の倍数に丸める
set shiftround

" :h indent.txt
" 後のものが有効にされると、前のものより優先される
" set autoindent    " 一つ前の行に基づくインデント
" set smartindent   " 'autoindent' と同様だが幾つかのC構文を認識し、適切な箇所のイン
                    " デントを増減させる。
set cindent         " 他の2つの方法よりも賢く動作し、設定することで異なるインデント
                    " スタイルにも対応できる。

" :h 'smartindent'
"   新しく作った行の最初の文字が '#' のとき、その行のインデントは取り除か
"   れ、'#' は最前列に置かれる。次の行のインデントは '#' の行の前と同じに
"   なる。こうしてほしくないなら、次のマッピングを使うこと。
"      ":inoremap # X^H#"
"   ここで ^H は CTRL-V CTRL-H と打ち込むと入力される。
"   コマンド ">>" を使ったとき、'#' で始まる行は右に移動しない。

" 不可視文字 {{{1
" ============================================================================
" 不可視文字の表示
set list
" tab: »-
" 行末の空白: ･
" ノーブレークスペース: _
" 画面の右側に文字があるとき: »
" 画面の左側に文字があるとき: «
set listchars=tab:»-,trail:･,nbsp:_,extends:»,precedes:«
" set listchars=tab:»-,trail:_,extends:»,precedes:«,nbsp:%,eol:↵

if has('conceal')
    " For snippet_complete marker.
    " concealcursor=nivにしない。隠さないほうがいいので空にする
    set conceallevel=2

    " autocmd MyVimrc Filetype json,markdown
    " \ setlocal concealcursor=
endif

" スペース以外の空白文字をハイライト {{{2
" ----------------------------------------------------------------------------
" （Vimテクニックバイブル1-11）+ unicode spacesもハイライトするようにした
" [Vimで全角空白以外のユニコードの空白文字もハイライト&取り除く - Qiita](http://qiita.com/tmsanrinsha/items/d6c11f2b7788eb24c776)
augroup MyVimrc
    autocmd ColorScheme * highlight UnicodeSpaces cterm=underline ctermfg=59 ctermbg=16 gui=underline guifg=#465457 guibg=#000000
    " autocmd ColorScheme *
    " \   execute 'highlight UnicodeSpaces'
    " \   . ' ctermfg=' . synIDattr(synIDtrans(hlID('SpecialKey')), 'fg', 'cterm')
    " \   . ' ctermbg=' . synIDattr(synIDtrans(hlID('SpecialKey')), 'bg', 'cterm')
    " \   . ' guifg=' .   synIDattr(synIDtrans(hlID('SpecialKey')), 'fg', 'gui')
    " \   . ' guibg=' .   synIDattr(synIDtrans(hlID('SpecialKey')), 'bg', 'gui')
    " \   . ' cterm=underline gui=underline'
    autocmd VimEnter,WinEnter * match UnicodeSpaces /\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000/
augroup END

" format {{{1
" ============================================================================
set textwidth=0

" :h fo-table
set formatoptions&
" r : Insert modeで<Enter>を押したら、comment leaderを挿入する
set formatoptions+=r
" M : マルチバイト文字の連結(J)でスペースを挿入しない
set formatoptions+=M
if MyHasPatch('patch-7.3.541') && MyHasPatch('patch-7.3.550')
    " j : コメント行の連結でcomment leaderを取り除く
    set formatoptions+=j
endif
" t : textwidthを使って自動的に折り返す
set formatoptions-=t
" c : textwidthを使って、コマントを自動的に折り返しcomment leaderを挿入する
set formatoptions-=c
" o : Normal modeでoまたOを押したら、comment leaderを挿入する
set formatoptions+=o

set formatexpr=

" mapping {{{1
" ============================================================================
" :h map-modes
" gvimにAltのmappingをしたい場合は先にset encoding=...をしておく

" key mappingに対しては9000ミリ秒待ち、key codeに対しては20ミリ秒待つ
" コマンドラインモードで<Esc>を押した時に消えるのが早くなるなど。
set timeout timeoutlen=9000 ttimeoutlen=20
if exists('+macmeta')
    " MacVimでMETAキーを使えるようにする
    set macmeta
endif
let g:mapleader = ';'
let g:maplocalleader = '\'

" prefix
" http://blog.bouzuya.net/2012/03/26/prefixedmap-vim/
" [:space:]でmapするようにするとVimFilerのスペースキーでキー待ちが発生しなくなる
nnoremap [:space:]   <Nop>
xnoremap [:space:]   <Nop>
nmap <Space> [:space:]
xmap <Space> [:space:]

" <Plug>を使っていいかも
" nmap <Space> <Plug>(my-space)
" nnoremap <Plug>(my-space) <Nop>

" noremap ; :
" noremap : ;

nnoremap [Colon] :

inoremap jj <ESC>
"cnoremap jj <ESC>
nnoremap Y y$

" カーソルを表示行で移動するようにする
nnoremap j gj
xnoremap j gj
nnoremap <down> gj
xnoremap <down> gj
nnoremap k gk
xnoremap k gk
nnoremap <up> gk
xnoremap <up> gk
nnoremap gj j
xnoremap gj j
nnoremap gk k
xnoremap gk k
nnoremap 0 g0
xnoremap 0 g0
nnoremap $ g$
" ヴィジュアルモード時は$で論理的行末まで行きたいのでコメントアウト
" xnoremap $ g$
nnoremap g0 0
xnoremap g0 0
nnoremap g$ $
xnoremap g$ $

" goto file
nnoremap gf gF
xnoremap gf gF
nnoremap gF gf
xnoremap gF gf
nnoremap <C-w>f <C-w>F
xnoremap <C-w>f <C-w>F
nnoremap <C-w>F <C-w>f
xnoremap <C-w>F <C-w>f
nnoremap <C-w>gf <C-w>gF
xnoremap <C-w>gf <C-w>gF
nnoremap <C-w>gF <C-w>gf
xnoremap <C-w>gF <C-w>gf

nnoremap ]h /\vhttps?:\/\/<CR>
nnoremap [h ?\vhttps\?://<CR>

nnoremap <M-s> :<C-u>w<CR>
inoremap <M-s> <Esc>:w<CR>

" <M-=>でカーソル前の数式の結果を=の後に出力する {{{2
" ----------------------------------------------------------------------------
" Vim scriptテクニックバイブル4-3によると
" <expr>
" <C-r>=
" <C-o>
" <Esc>
" の順にいいらしい
inoremap <expr> <M-=> "\<C-g>u" . EvalExpression()

function! EvalExpression() abort
    let expression = getline('.')
    let expression = matchstr(expression, '[0-9.+\-*/() ]\+')
    " 1/4を0.25としてほしいのでluaeval()を使う
    return ' = ' . string(luaeval(expression))
endfunction

" swap, backup, undo {{{1
" ============================================================================
" updatetimeを短くして、CursorHoldに使うので
" swap fileがupdatetimeごと頻繁に作成されないようにnoswapfileにする
" vimfilerを使っているとnoswapfileに設定される
" set noswapfile
"" デフォルトの設定にある~/tmpを入れておくと、swapファイルが自分のホームディレクトリ以下に生成されてしまい、他の人が編集中か判断できなくなるので除く
""   set directory&
""   set directory-=~/tmp
""   " 他の人が編集する可能性がない場合はswapファイルを作成しない
""   if has('win32') || has('mac')
""       set noswapfile
""   endif
" 個人的に便利だと思うVimの基本設定のランキングを発表します！ - プログラムモグモグ
" http://itchyny.hatenablog.com/entry/2014/12/25/090000
" FreeBSD, Macでcrontab -eしたときに
"   crontab: temp file must be edited in place
" というエラーが出てcrontabが更新されないときの対策
" [crontabをVimで編集した時に出るエラーの対処法](http://sanrinsha.lolipop.jp/blog/2013/03/post-10825.html)
set backupskip&
set backupskip+=/home/tmp/*,/private/tmp/*

" 富豪的バックアップ {{{2
" ----------------------------------------------------------------------------
" http://d.hatena.ne.jp/viver/20090723/p1
" http://synpey.net/?p=127
" savevers.vimが場合はそちらを使う
if ! isdirectory(expand('~/.vim/bundle/savevers.vim'))
    set backup
    set backupdir=$VIM_CACHE_DIR/backup

    augroup backup
        autocmd!
        autocmd BufWritePre,FileWritePre,FileAppendPre * call UpdateBackupFile()
        function! UpdateBackupFile()
            let l:basedir = expand('$VIM_CACHE_DIR/backup')
            let l:dir = strftime(l:basedir.'/%Y%m/%d', localtime()).substitute(expand('%:p:h'), '\v\c^([a-z]):', '/\1/' , '')
            if !isdirectory(l:dir)
                call mkdir(l:dir, 'p')
            endif

            let l:dir = escape(l:dir, ' ')
            exe 'set backupdir='.l:dir
            let l:time = strftime('%H-%M', localtime())

            execute 'set backupext=.'.l:time
        endfunction
    augroup END
endif

" アンドゥの履歴をファイルに保存し、Vim を一度終了したとしてもアンドゥやリドゥを行えるようにする {{{2
" ----------------------------------------------------------------------------
" 開いた時に前回保存時と内容が違う場合はリセットされる
if has('persistent_undo')
    set undofile
    if !isdirectory($VIM_CACHE_DIR.'/undo')
        call mkdir($VIM_CACHE_DIR.'/undo', 'p')
    endif
    set undodir=$VIM_CACHE_DIR/undo
endif

" 前回のカーソル位置にジャンプ {{{2
" ----------------------------------------------------------------------------
" Always Jump to the Last Known Cursor Position
autocmd MyVimrc BufReadPost *
\   if line("`\"") > 1 && line("`\"") <= line("$") |
\       execute "normal! g`\"" |
\   endif

" session {{{2
" ----------------------------------------------------------------------------
" optionsを設定するとおかしくなる
set sessionoptions-=options
autocmd MyVimrc VimLeavePre * call s:save_session()

function! s:save_session()
    if !empty(expand('%'))
        mksession! $VIM_CACHE_DIR/session.vim 
    endif
endfunction

" statusline {{{1
" ============================================================================
" 最下ウィンドウにいつステータス行が表示されるかを設定する。
" 0: 全く表示しない
" 1: ウィンドウの数が2以上のときのみ表示
" 2: 常に表示
set laststatus=2
" statuslineはlightline.vimでやっている
" :help 'statusline'
" f     バッファ内のファイルのパス(入力された通り、またはカレントディレクトリに対する相対パス)
" m     修正フラグ
" =     ここから右寄せ
" r     読み込み専用フラグ
" fenc  ファイルエンコード
" enc   Vim内部で使うエンコード
" ff    ファイルフォーマット（改行コード）
" Y     ファイルタイプ
" P     現在の行がファイル内の何%の位置にあるか
" %v    何列目
" %l    何行目
" set statuslineで設定するとスペースを入れるために'\ '、縦線を入れるために'\|'のようにエスケープしなくてはならないので
" let &statuslineで設定する
" let &statusline = '%f%m%=%r%{(&fenc!=""?&fenc:&enc)} | %{&ff} | %Y | %P | %v:%l'

" titlestring {{{1
" ============================================================================
set title
let &titlestring = "%{expand('%:p')} @" . hostname()

" tmux使用時もtitlestringを変更できるように設定する
if &term =~? 'screen'
    let &t_ts = "\ePtmux;\e\e]2;"
    let &t_fs = "\007\e\\"
endif

" buffer {{{1
" ============================================================================
" nnoremap <M-n> :bnext<CR>
" nnoremap <M-p> :bprevious<CR>

" window {{{1
" ============================================================================
" nnoremap <M-h> <C-w>h
" nnoremap <M-j> <C-w>j
" nnoremap <M-k> <C-w>k
" nnoremap <M-l> <C-w>l
nnoremap <M--> <C-w>-
nnoremap <M-+> <C-w>+
nnoremap <M-,> <C-w><
nnoremap <M-.> <C-w>>
nnoremap <M-0> <C-w>=
nnoremap <C-w><C-w> <C-w>p

set splitbelow
set splitright

" カーソルの上下に最低でも1行は表示させる。常にカーソル行を真ん中にする場合は999など
set scrolloff=1
" 左右スクロール時
set sidescrolloff=2
" 横スクロールを1文字ずつ
set sidescroll=1

" ウィンドウ分割時に等分にしない
" fugitiveを使った時のdiffが等分になって欲しいのでコメントアウト
" set noequalalways

"縦分割されたウィンドウのスクロールを同期させる
"同期させたいウィンドウ上で<F12>を押せばおｋ
"解除はもう一度<F12>を押す
"横スクロールも同期させたい場合はこちら
"http://ogawa.s18.xrea.com/fswiki/wiki.cgi?page=Vim%A4%CE%A5%E1%A5%E2
"nnoremap <F12> :set scrollbind!<CR>

" tab page {{{1
" ============================================================================
"  いつタブページのラベルを表示するかを指定する。
"  0: 表示しない
"  1: 2個以上のタブページがあるときのみ表示
"  2: 常に表示
set showtabline=1

nnoremap [TAB] <Nop>
nmap <Leader>t [TAB]
" 一番右にタブを作る
" nnoremap <M-t> :tablast <Bar> tabnew<CR>
nnoremap <M-t> :tabnew<CR>

nnoremap [TAB]q :tabclose<CR>

nnoremap <C-Tab> :tabn<CR>
nnoremap <S-C-Tab> :tabp<CR>

nnoremap [TAB]n :tabn<CR>
nnoremap [TAB]p :tabp<CR>

nnoremap <M-n> gt
nnoremap <M-p> gT
nnoremap <M-1> :1tabn<CR>
nnoremap <M-2> :2tabn<CR>
nnoremap <M-3> :3tabn<CR>
nnoremap <M-4> :4tabn<CR>
nnoremap <M-5> :5tabn<CR>
nnoremap <M-6> :6tabn<CR>
nnoremap <M-7> :7tabn<CR>
nnoremap <M-8> :8tabn<CR>
nnoremap <M-9> :9tabn<CR>
nnoremap <M-0> :10tabn<CR>
nnoremap [TAB]1 :1tabn<CR>
nnoremap [TAB]2 :2tabn<CR>
nnoremap [TAB]3 :3tabn<CR>
nnoremap [TAB]4 :4tabn<CR>
nnoremap [TAB]5 :5tabn<CR>
nnoremap [TAB]6 :6tabn<CR>
nnoremap [TAB]7 :7tabn<CR>
nnoremap [TAB]8 :8tabn<CR>
nnoremap [TAB]9 :9tabn<CR>
nnoremap [TAB]0 :10tabn<CR>

" Command-line mode {{{1
" ============================================================================
"コマンド入力時にTabを押すと補完メニューを表示する。決定したい時は文字を打つか、ctrl-eなど。
set wildmenu
" コマンドモードの補完をシェルの補完のような動きにする
" <TAB>で共通する最長の文字列まで補完して一覧表示
" 再度<Tab>を打つと候補を選択。<S-Tab>で逆
" 決定したい時は文字を打つか、ctrl-eなど。
set wildmode=list:longest,full

" 保存する履歴の数
set history=10000

"前方一致をCtrl+PとCtrl+Nで
cnoremap <C-P> <UP>
cnoremap <C-N> <DOWN>
cnoremap <UP> <C-P>
cnoremap <DOWN> <C-N>

nnoremap Q q:

" vim-emacscommandlineで<C-F>は右に進むになっているので、
" コマンドラインウィンドウを開きたいときは<C-Space>にする
cnoremap <C-Space> <C-F>

" 外部コマンド実行でエイリアスを使うための設定
" http://sanrinsha.lolipop.jp/blog/2013/09/vim-alias.html
" bashスクリプトをquickrunで実行した時にエイリアス展開されてしまうのでコメント
" アウト
" let $BASH_ENV=expand('~/.bashenv')
" let $ZDOTDIR=expand('~/.vim/')
" }}}
" cmdline-window {{{
" ============================================================================
" http://vim-users.jp/2010/07/hack161/
" nnoremap <sid>(command-line-enter) q:
" xnoremap <sid>(command-line-enter) q:
" nnoremap <sid>(command-line-norange) q:<C-u>
"
" nmap :  <sid>(command-line-enter)
" xmap :  <sid>(command-line-enter)

autocmd MyVimrc CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin()
    nnoremap <buffer> q :<C-u>quit<CR>
    nnoremap <buffer> <TAB> :<C-u>quit<CR>
    inoremap <buffer><expr><CR> pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
    " inoremap <buffer><expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
    " inoremap <buffer><expr><BS> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"

    " Completion.
    inoremap <buffer><expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <buffer><expr><C-p>  pumvisible() ? "\<C-p>" : "\<C-x>\<C-l>"

    startinsert!
endfunction
" }}}
" ビジュアルモード {{{1
" =============================================================================
" ビジュアル矩形モードでなくても、IやAで挿入できるようにする {{{
" -----------------------------------------------------------------------------
" http://labs.timedia.co.jp/2012/10/vim-more-useful-blockwise-insertion.html
vnoremap <expr> I  <SID>force_blockwise_visual('I')
vnoremap <expr> A  <SID>force_blockwise_visual('A')

function! s:force_blockwise_visual(next_key)
    if mode() ==# 'v'
        return "\<C-v>" . a:next_key
    elseif mode() ==# 'V'
        return "\<C-v>0o$" . a:next_key
    else  " mode() ==# "\<C-v>"
        return a:next_key
    endif
endfunction
" 最後に変更したテキスト（ペーストした部分など）を選択
" ----------------------------------------------------------------------------
nnoremap gm `[v`]
vnoremap gm :<C-u>normal gm<CR>
onoremap gm :<C-u>normal gm<CR>
"}}}
"}}}
" diretory, path {{{1
" ============================================================================
"augroup CD
"    autocmd!
"    autocmd BufEnter * execute ":lcd " . expand("%:p:h")
"augroup END
" 現在編集中のファイルのディレクトリをカレントディレクトリにする
nnoremap [:space:]gc :cd %:h <Bar> echo 'cd '.expand('%:p:h')<CR>
nnoremap [:space:]gc :cd %:h <Bar> echo 'cd '.expand('%:p:h')<CR>

command! Shell lcd %:h <Bar> shell

" file name
inoremap <C-r>f <C-r>=expand("%:t")<CR>
cnoremap <C-r>f <C-r>=expand("%:t")<CR>
" full path of file
inoremap <C-r>F <C-r>=expand('%:p')<CR>
cnoremap <C-r>F <C-r>=expand('%:p')<CR>
" full path of directory
inoremap <C-r>d <C-r>=expand('%:p:h')<CR>/
cnoremap <C-r>d <C-r>=expand('%:p:h')<CR>/

" yank file name
nnoremap yf :let @" = expand("%:t") <Bar> echo 'yanked: ' . expand("%:t")<CR>
" yank full path of file
nnoremap yF :let @" = expand('%:p') <Bar> echo 'yanked: ' . expand("%:p")<CR>
" yank full path of directory
nnoremap yd :let @" = expand('%:p:h') <Bar> echo 'yanked: ' . expand("%:p:h")<CR>

" copy file name
nnoremap [:space:]yf :let @* = expand("%:t") <Bar> echo 'copied: ' . expand("%:t")<CR>
" copy full path of file
nnoremap [:space:]yF :let @* = expand('%:p') <Bar> echo 'copied: ' . expand("%:p")<CR>
" copy full path of directory
nnoremap [:space:]yd :let @* = expand('%:p:h') <Bar> echo 'copied: ' . expand("%:P:h")<CR>

" Rename {{{2
" ----------------------------------------------------------------------------
" Vim-users.jp - Hack #17: Vimを終了することなく編集中ファイルのファイル名を変更する
" http://vim-users.jp/2009/05/hack17/
" command! -nargs=1 -complete=file Rename f <args>|call delete(expand('#'))
" 上のコマンドだとパーミッションは引き継がれないので、mvで処理するようにする。
command! -nargs=1 -complete=file Rename call s:move(expand('%'), '<args>')
function! s:move(src, dest)
    call system('mv '.a:src.' '.a:dest)
    execute 'e '.a:dest
    bdelete #
endfunction
" TODO: rename()を試す

" Resolve {{{2
" ----------------------------------------------------------------------------
" リンクの実体で開き直す
command! Resolve call s:resolve_edit()
function! s:resolve_edit() abort
    let l:file = resolve(expand('%'))
    new
    bwipeout #
    execute 'edit '.l:file
endfunction

" Vim-users.jp - Hack #202: 自動的にディレクトリを作成する <http://vim-users.jp/2011/02/hack202/> {{{2
autocmd MyVimrc BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
function! s:auto_mkdir(dir, force)
    if !isdirectory(a:dir) && (a:force ||
        \    input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
        call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
    endif
endfunction

" ctags {{{1
" ============================================================================
if has('path_extra')
    set tags+=~/tags
endif

function! s:ctags(dir)
    call system('ctags -R -f ~/tags "'.fnamemodify(a:dir, ':p').'" &')
endfunction
command! -nargs=1 -complete=file Ctags call s:ctags('<args>')

" Gitリポジトリ以下のときに、保存するたびにctagsを実行 {{{2
" ----------------------------------------------------------------------------
" http://sanrinsha.lolipop.jp/blog/2014/04/git-hook-ctags.html
autocmd MyVimrc BufWritePost *
\ if exists('b:git_dir') && executable(b:git_dir.'/hooks/ctags') |
\   call system('"'.b:git_dir.'/hooks/ctags" &') |
\ endif

" tsukkee/unite-tag *unite-tag* {{{2
" ----------------------------------------------------------------------------
nnoremap [unite]t :<C-u>Unite tag<CR>
" let g:unite_source_tag_max_fname_length = 1000
" let g:unite_source_tag_max_name_length = 100
" let g:unite_source_tag_strict_truncate_string = 0

" filetypeがjavaのとき以外
" gitのhookで.git/tagsが生成されるように設定しておく
" [GitのhookでCtagsを実行する | SanRin舎](http://sanrinsha.lolipop.jp/blog/2014/04/git-hook-ctags.html)
autocmd MyVimrc FileType * call s:configure_tag()

function! s:configure_tag()
    if (!empty(&buftype) && &buftype !=# 'help') || &filetype ==# 'java'
        return
    endif

    if &filetype =~# 'vim\|help'
        execute 'setlocal tags+=' . g:dein_dir . '/repos/**/.git/tags'
        " globpathの引数が4つまでになるのは7.4.279以上
        " [Vim script言語仕様の変更 · rbtnn/vimscript Wiki](https://github.com/rbtnn/vimscript/wiki/Vim-script%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%AE%E5%A4%89%E6%9B%B4)
        " execute 'setlocal tags+='.join(globpath(&runtimepath, '.git/tags', 0, 1), ',')
        " execute 'setlocal tags+='.substitute(globpath(&runtimepath, '.git/tags', 0), "\<NL>", ',', 'g')
    endif

    nnoremap <buffer> <C-]> :UniteWithCursorWord -immediately tag<CR>
endfunction

" tagsにその都度個別に追加する版 {{{3
" 全部tagsに追加しても遅くないのと#使ってないものが検索できないのでやめた
" " helpやfiletypeがjavaのとき以外
" " autocmd MyVimrc FileType *
" \   if empty(&buftype) && &filetype != 'java'
" \|      nnoremap <buffer> <C-]> :<C-u>MyUniteTag<CR>
" \|  endif
"
" function! s:
"     if &filetype == 'vim'
"         " quickrun#is_runnig()などの上で<C-]>したときにquickrunリポジトリ
"         " の.git/tagsをtagsに追加する。
"         let plugin_name = matchstr(expand('<cword>'), '[^#]\+\ze#')
"         if plugin_name != ''
"           " execute 'setlocal tags+='.substitute(globpath(&runtimepath, 'autoload/'.plugin_name.'.vim'), 'autoload/'.plugin_name.'.vim', '.git/tags', '')
"         endif
"     endif
"     UniteWithCursorWord -immediately tag
" endfunction
" command! MyUniteTag call s:
" }}}

" crypt {{{1
" ============================================================================
" [Using VIM as Your Password Manager - Stelfox Athenæum](http://stelfox.net/blog/2013/11/using-vim-as-your-password-manager/)
" 暗号化して保存するためには
"   :set cryptmethod=blowfish2 (Vim 7.4.399以前はblowfish)
"   :X
" has('crypt-blowfish'), has('crypt-blowfish')で使用できる暗号化アルゴリズムを確認できる
autocmd MyVimrc BufReadPost *
\   if &key != ""
\ |     setlocal noswapfile nowritebackup noshelltemp secure
\ | endif

" man {{{1
" ============================================================================
" runtime ftplugin/man.vimで使えるManコマンドは
" - macでのManの調子が悪い
" - 補完がきかない
" のでvim-refの:Ref manを使うことにする
" [vim-utils/vim-man: View and grep man pages in vim](https://github.com/vim-utils/vim-man)
" はオリジナルのman.vimを改変したもので、補完は効くようになったが、cuiのmacvimでうまくいかない

" :Man <man>でマニュアルを開く
" http://vim.wikia.com/wiki/Using_vim_as_a_man-page_viewer_under_Unix
" [manをVimで見る - rcmdnk's blog](http://rcmdnk.github.io/blog/2014/07/20/computer-vim/)
" runtime ftplugin/man.vim
" nmap K <Leader>K
" let $PAGER=''
" コマンドラインでmanを使ったとき、vimの:Manで見るようにするためには
".zshrc .bashrc等にも記述が必要

" printing {{{1
" ============================================================================
set printoptions=wrap:y,number:y,header:0
set printfont=Andale\ Mono:h12:cUTF8

" quickfix, make {{{1
" ============================================================================
nmap [q <Plug>(QuickFixCurrentNumberQPrev)
nmap ]q <Plug>(QuickFixCurrentNumberQNext)
nnoremap [Q :cprevious<CR>
nnoremap ]Q :cnext<CR>
noremap [*quickfix] <Nop>
nmap <Leader>q [*quickfix]
noremap [*quickfix]o :botright copen<CR>
noremap [*quickfix]q :cclose<CR>
nnoremap [L :<C-u>lprevious<CR>
nnoremap ]L :<C-u>lnext<CR>
noremap [*location] <Nop>
nmap <Leader>l [*location]
noremap [*location]o :lopen<CR>
noremap [*location]q :lclose<CR>

autocmd MyVimrc FileType qf
\   nnoremap <buffer> q :q<CR>

" 現在のカーソル位置の次/前のquickfix/location listに飛ぶにはQuickFixCurrentNumberを使う
" http://www.vim.org/scripts/script.php?script_id=4449

" show quickfix automatically {{{2
" ----------------------------------------------------------------------------
" これをやるとneocomlcacheの補完時にquickfix winodow（中身はtags）が開くのでコメントアウト
" autocmd MyVimrc QuickfixCmdPost * if !empty(getqflist()) | botright cwindow | botright lwindow | endif

" quickfixの高さを最小にする {{{2
" ----------------------------------------------------------------------------
" Automatically fitting a quickfix window height - Vim Tips Wiki
" http://vim.wikia.com/wiki/Automatically_fitting_a_quickfix_window_height
autocmd MyVimrc FileType qf call s:adjust_qf_window_height(1, 12)
function! s:adjust_qf_window_height(minheight, maxheight)
    let l:l = 1
    let l:n_lines = 0
    let l:w_width = winwidth(0)
    while l:l <= line('$')
        " number to float for division
        let l:l_len = strlen(getline(l:l)) + 0.0
        let l:line_width = l:l_len/l:w_width
        let l:n_lines += float2nr(ceil(l:line_width))
        let l:l += 1
    endw
    execute max([min([l:n_lines, a:maxheight]), a:minheight]) . 'wincmd _'
endfunction

" errorformatの確認のための関数 {{{2
" ----------------------------------------------------------------------------
" Vim - errorformatについて(入門編) - Qiita
" <http://qiita.com/rbtnn/items/92f80d53803ce756b4b8>
function! TestErrFmt(errfmt,lines)
    let l:temp_errorfomat = &errorformat
    try
        let &errorformat = a:errfmt
        cexpr join(a:lines,"\n")
        copen
    catch
        echo v:exception
        echo v:throwpoint
    finally
        let &errorformat = l:temp_errorfomat
    endtry
endfunction

" Vim script でエラーが出た時のmessagesのエラー箇所に飛ぶ {{{2
" ----------------------------------------------------------------------------
function! s:qf_messages()
  let str_messages = ''
  redir => str_messages
  silent! messages
  redir END

  let qflist = s:parse_error_messages(str_messages)
  call setqflist(qflist, 'r')
  cwindow
endfunction

function! s:parse_error_messages(messages) abort
    " 戻り値。setqflistの引数に使う配列
    let qflist = []
    " qflistの要素になる辞書
    let qf_info = {}
    " qflistの要素となる辞書の配列。エラー内容がスタックトレースのときに使用
    let qf_info_list = []
    " 読み込んだファイルの内容をキャッシュしておくための辞書
    let files = {}

    if v:lang =~# 'ja_JP'
        let regex_error_detect = '^.\+\ze の処理中にエラーが検出されました:$'
        let regex_line = '^行\s\+\zs\d\+\ze:$'
        let regex_last_set = '最後にセットしたスクリプト: \zs\f\+'
    else
        let regex_error_detect = '^Error detected while processing \zs.\+\ze:$'
        let regex_line = '^line\s\+\zs\d\+\e:$'
        let regex_last_set = 'Last set from \zs\f\+'
    endif

    for line in split(a:messages, "\n")
        if line =~# regex_error_detect
            " ... の処理中にエラーが検出されました:'
            let matched = matchstr(line, regex_error_detect)
            if matched =~# '^function'
                " function <SNR>253_fuga の処理中にエラーが検出されました:
                " function <SNR>253_piyo[1]..<SNR>253_fuga の処理中にエラーが検出されました:
                let matched = matchstr(matched, '^function \zs\S*')
                let stacks = reverse(split(matched, '\.\.'))
                for stack in stacks
                    let [func_name, offset] = (stack =~# '\S\+\[\d')
                    \ ? matchlist(stack, '\(\S\+\)\[\(\d\+\)\]')[1:2]
                    \ : [stack, 0]

                    " 辞書関数の数字は{}で囲む
                    let func_name = func_name =~# '^\d\+$' ? '{' . func_name . '}' : func_name

                    redir => verbose_func
                    execute 'silent verbose function ' . func_name
                    redir END

                    let filename = matchstr(verbose_func, regex_last_set)
                    let filename = expand(filename)

                    if !has_key(files, filename)
                        let files[filename] = readfile(filename)
                    endif

                    if func_name =~# '{\d\+}'
                        let func_lines = split(verbose_func, "\n")
                        unlet func_lines[1]
                        let max_line = len(func_lines)
                        let func_lines[0] = '^\s*fu\%[nction]!\=\s\+\zs\S\+\.\S\+'

                        for i in range(1, max_line - 2)
                            let func_lines[i] = '^\s*' . matchstr(func_lines[i], '^\d\+\s*\zs.*')
                        endfor

                        let func_lines[max_line - 1] = '^\s*endf[unction]'

                        let lnum = 0
                        while 1
                            let lnum = match(files[filename], func_lines[0], lnum)

                            if lnum < 0
                                throw 'No dictionary function'
                            endif

                            let find_dic_func = 1
                            for i in range(1, max_line - 1)
                                if files[filename][lnum + i] !~# func_lines[i]
                                    let lnum = lnum + i
                                    let find_dic_func = 0
                                    break
                                endif
                            endfor

                            if find_dic_func
                                break
                            endif
                        endwhile

                        let func_name = matchstr(files[filename][lnum], func_lines[0])
                        let lnum += 1 + offset
                    else
                        let func_name  = substitute(func_name, '<SNR>\d\+_', 's:', '')
                        let lnum = match(files[filename], '^\s*fu\%[nction]!\=\s\+' . func_name) + 1 + offset
                    endif

                    call add(qf_info_list, {
                    \   'filename': filename,
                    \   'lnum': lnum,
                    \   'text': func_name,
                    \})
                endfor
            else
                " <filename> の処理中にエラーが検出されました:
                let filename = expand(matchstr(line, regex_error_detect))
                let qf_info.filename = expand(filename)
            endif
        elseif line =~# regex_line
            " 行    1:
            let lnum = matchstr(line, regex_line)
            if len(qf_info_list) > 0
                let qf_info_list[0]['lnum'] += lnum
            else
                let qf_info.lnum = lnum
            endif
        elseif line =~# '^E'
            " E492: エディタのコマンドではありません: one
            let [nr, text] = matchlist(line, '^E\(\d\+\): \(.\+\)')[1:2]
            if len(qf_info_list) > 0
                if len(qf_info_list) == 1
                    let qf_info_list[0]['nr'] = nr
                    let qf_info_list[0]['text'] = 'in ' . qf_info_list[0]['text'] . ' | ' . text
                else
                    let i = 0
                    for val in qf_info_list
                        let val['nr'] = nr
                        let val['text'] = '#' . i . ' in ' . val['text'] . (i == 0 ? (' | ' . text) : '')
                        let i += 1
                    endfor
                endif
                let qflist += qf_info_list
            else
                let qf_info.nr = nr
                let qf_info.text = text
                call add(qflist, qf_info)
            endif

            let qf_info = {}
            let qf_info_list = []
        endif
    endfor

    return qflist
endfunction

command! -nargs=0 QfMessages call s:qf_messages()
nnoremap [*quickfix]m :<C-u>QfMessages<CR>

" 参考サイト
" * [Vim scriptをsourceしてエラーがあればquickfixに表示する - ぼっち勉強会](http://kannokanno.hatenablog.com/entry/20120723/1343147069)

" Ip2host {{{1
" ============================================================================
function! s:Ip2host(line1, line2)
    for l:linenum in range(a:line1, a:line2)
        let l:oldline = getline(l:linenum)
        let l:newline = substitute(l:oldline,
                    \   '\v((%(2%([0-4]\d|5[0-5])|1\d\d|[1-9]?\d)\.){3}%(2%([0-4]\d|5[0-5])|1\d\d|[1-9]?\d))',
                    \   '\=substitute(system("nslookup ".submatch(1)), "\\v.*%(name = |:    )([0-9a-z-.]+).*", "\\1","")',
                    \   '')
        call setline(l:linenum, l:newline)
    endfor
endfunction

command! -range=% Ip2host call s:Ip2host(<line1>, <line2>)

" filetype {{{1
" ============================================================================
nnoremap [FILETYPE] <Nop>
nmap <Leader>F [FILETYPE]

nnoremap [FILETYPE]d  :<C-u>setlocal filetype=diff<CR>
nnoremap [FILETYPE]h  :<C-u>setlocal filetype=html<CR>
nnoremap [FILETYPE]j  :<C-u>setlocal filetype=javascript<CR>
nnoremap [FILETYPE]m  :<C-u>setlocal filetype=markdown<CR>
nnoremap [FILETYPE]ph :<C-u>setlocal filetype=php<CR>
nnoremap [FILETYPE]py :<C-u>setlocal filetype=python<CR>
nnoremap [FILETYPE]R  :<C-u>setlocal filetype=r<CR>
nnoremap [FILETYPE]s  :<C-u>setlocal filetype=sql<CR>
nnoremap [FILETYPE]s  :<C-u>setlocal filetype=sql<CR>
nnoremap [FILETYPE]sh :<C-u>let      b:sql_type_overrride    = 'hive' <Bar> setlocal filetype=sql<CR>
nnoremap [FILETYPE]v  :<C-u>setlocal filetype=vim<CR>
nnoremap [FILETYPE]x  :<C-u>setlocal filetype=xml<CR>

" プラグインなどで変更された設定をグローバルな値に戻す
" *.txtでtextwidth=78されちゃう
" [vimrc_exampleのロードのタイミング - Google グループ](https://groups.google.com/forum/#!topic/vim_jp/Z_3NSVO57FE "vimrc_exampleのロードのタイミング - Google グループ")
autocmd MyVimrc FileType vim,text,markdown call s:override_plugin_setting()
" autocmd MyVimrc FileType vim,text call s:override_plugin_setting()

function! s:override_plugin_setting()
    setlocal textwidth<
    setlocal textwidth=0
    setlocal formatoptions<
endfunction

" shell {{{2
" ----------------------------------------------------------------------------
autocmd MyVimrc FileType sh setlocal errorformat=%f:\ line\ %l:\ %m

" HTML {{{2
" ----------------------------------------------------------------------------
function! s:live_reload(dir) abort
    if !executable('livereloadx')
        if input('livereloadx is not installed. npm -g install livereloadx? [y/N]') =~? '^y\%[es]$'
            if !executable('npm')
                echo 'npm is not found'
                return
            endif
            !npm -g install livereloadx
        else
            return
        endif
    endif

    let sub = vimproc#popen2('livereloadx --include ''*.md'' -s '.a:dir)
    augroup LiveReload
        execute 'autocmd LiveReload VimLeavePre * call vimproc#kill('.sub.pid.', 15)'
    augroup END
    call vimproc#popen2('open -a Google\ Chrome http://localhost:35729/'.expand('%:t:r').'.html')
endfunction

command! LiveReloadBufferDir call s:live_reload(expand('%:p:h'))
command! LiveReloadProjectDir call s:live_reload(GetProjectDir())

" Markdown {{{2
" ----------------------------------------------------------------------------
" pandocでhtmlからmarkdownに変換 {{{3
autocmd MyVimrc FileType markdown,html
\   command! Markdownize :%!pandoc -f html -t markdown_phpextra --wrap=none

autocmd MyVimrc FileType markdown
\   nnoremap <buffer> <Leader>r :<C-u>PrevimOpen<CR>
\ | command! -range=% MarkdownStrict :<line1>,<line2>!pandoc -f markdown+hard_line_breaks -t markdown_strict --wrap=none

" JavaScript {{{2
" ----------------------------------------------------------------------------
autocmd MyVimrc FileType javascript call s:configure_javascript()

function! s:configure_javascript()
    setlocal syntax=jquery
    " .を入れたほうがneocompleteの補完がうまくいく
    " setlocal iskeyword+=.
endfunction

" Java {{{2
" ----------------------------------------------------------------------------
if isdirectory(expand('~/AppData/Local/Android/android-sdk/sources/android-17'))
    autocmd MyVimrc FileType java setlocal path+=~/AppData/Local/Android/android-sdk/sources/android-17
elseif isdirectory(expand('/Program Files (x86)/Android/android-sdk/sources/android-17'))
    autocmd MyVimrc FileType java setlocal path+=/Program\ Files\ (x86)/Android/android-sdk/sources/android-17
endif
autocmd MyVimrc FileType java
            \   setlocal foldmethod=syntax
            \|  nnoremap <buffer>  [[ [m
            \|  nnoremap <buffer>  ]] ]m

" Vim {{{2
" ----------------------------------------------------------------------------
" \を打った時のindentの幅
" let g:vim_indent_cont = &sw
let g:vim_indent_cont = 0

" http://vim-users.jp/2009/09/hack74/
" .vimrcと.gvimrcの編集
nnoremap [VIM] <Nop>
nmap <Leader>v [VIM]

execute 'nnoremap [VIM]e :<C-u>edit '.s:dotfiles_home.'/.vim/vimrc<CR>'
execute 'nnoremap [VIM]E :<C-u>edit '.s:dotfiles_home.'/.vim/gvimrc<CR>'
execute 'nnoremap [VIM]b :<C-u>edit '.s:dotfiles_home.'/.vim/rc/neobundle.vim<CR>'
execute 'nnoremap [VIM]p :<C-u>edit '.s:dotfiles_home.'/.vim/rc/plugin.vim<CR>'
execute 'nnoremap [VIM]d :<C-u>edit '.s:dotfiles_home.'/.vim/rc/dein.vim<CR>'
" vimrcの実体を開く。systemだと最後に<NL>が入ってうまくいかない
" execute 'nnoremap [VIM]l :<C-u>edit '.substitute(system('readlink ~/.vim/rc/local.vim'),  "\<NL>", '', '').'<CR>'
execute 'nnoremap [VIM]l :<C-u>edit '.resolve(expand('~/.vim/rc/local.vim')).'<CR>'

" Load .gvimrc after .vimrc edited at GVim.
nnoremap <silent> [VIM]r :<C-u>new \| source $MYVIMRC \| if has('gui_running') \| source $MYGVIMRC \| endif \| q \| echo 'vimrc reloaded!'<CR>

""vimrc auto update
"augroup MyAutoCmd
"  autocmd!
"  " nested: autocmdの実行中に更に別のautocmdを実行する
"  autocmd BufWritePost .vimrc nested source $MYVIMRC
"  " autocmd BufWritePost .vimrc RcbVimrc
"augroup END

" autocmd MyVimrc BufWritePost *.vim
"     \   if filereadable(expand('%'))
"     \|       source %
"     \|  endif

" vimperator {{{2
" ----------------------------------------------------------------------------
autocmd MyVimrc FileType vimperator
\   setlocal comments=:\"

" help {{{2
" ----------------------------------------------------------------------------
" set helplang=en,ja
autocmd MyVimrc FileType help call s:setting_help()

function! s:setting_help()
    nnoremap <buffer><silent> K <C-]>
    nnoremap <buffer><silent> q :q<CR>
    " nnoremap <buffer> ]]     /<Bar>.*<Bar><CR>
    nnoremap <buffer> ]<Bar> /<Bar>.*<Bar><CR>
    nnoremap <buffer> [[     ?<Bar>.*<Bar><CR>
    nnoremap <buffer> [<Bar> ?<Bar>.*<Bar><CR>
    nnoremap <buffer> ]' /'.*'<CR>
    nnoremap <buffer> [' /'.*'<CR> |
    " デフォルトは!-~,^*,^|,^",192-255だが()を外したい。
    " -=()が効かない?
    setlocal iskeyword=!-39,42-~,^*,^\|,^\",192-255
endfunction

" Git {{{2
" ----------------------------------------------------------------------------
" コミットメッセージは72文字で折り返す
" http://keijinsonyaban.blogspot.jp/2011/01/git.html
" 72列目に線を引く
" Insert modeで始める
autocmd MyVimrc BufRead */.git/COMMIT_EDITMSG
    \   setlocal colorcolumn=+1
    \|  startinsert
" ftpluginによって、自動で折り返す設定になるので、自分のvimrcで設定したglobalな値に戻す
autocmd MyVimrc FileType gitcommit
    \  setlocal formatoptions<
" }}}

" memo {{{1
" ============================================================================
if !exists('g:memo_directory')
    let g:memo_directory = expand('~/Dropbox/memo/doc')
endif
" }}}

if !has('gui_running')
    call SourceRc('cui.vim')
endif

if v:version >= 704
    call SourceRc('dein.vim')
elseif MyHasPatch('patch-7.2.051')
    call SourceRc('neobundle.vim')
    call SourceRc('plugin.vim')
else
    " bundle以下にあるpluginをいくつかruntimepathへ追加する
    " let s:load_plugin_list = [
    " \   'sudo.vim', 'my_molokai', 'vim-smartword'
    " \]
    " " for path in split(glob($HOME.'/.vim/bundle/*'), '\n')
    " "     let s:plugin_name = matchstr(path, '[^/]\+$')
    " "     if isdirectory(path) && index(s:load_plugin_list, s:plugin_name) >= 0
    " "         let &runtimepath = &runtimepath.','.path
    " "     end
    " " endfor
    " for s:plugin in s:load_plugin_list
    "     if isdirectory($HOME.'/.vim/bundle/'.s:plugin)
    "         let &runtimepath = &runtimepath . ',' . g:dein_dir . '/repos/github.com/vim-scripts/sudo.vim'
    "     endif
    " endfor

    let &runtimepath = &runtimepath . ',' . g:dein_dir . '/repos/github.com/vim-scripts/sudo.vim'
    nnoremap <Leader>W :w sudo:%<CR>

    filetype plugin indent on
endif

" search/substitute {{{1
" ============================================================================
" インクリメンタルサーチ
set incsearch
" 検索パターンの大文字小文字を区別しない
set ignorecase
" 検索パターンに大文字が含まれていたら、大文字小文字を区別する。
set smartcase
set hlsearch   "検索結果をハイライト

" ESCキー2度押しでハイライトのトグル
nnoremap <Esc><Esc> :<C-u>set hlsearch!<CR>

if IsInstalled('vim-asterisk')
    map *  <Plug>(asterisk-z*)
    " map #  <Plug>(asterisk-z#)
    map #  <Plug>(asterisk-gz#)
    " map g* <Plug>(asterisk-gz*)
    " map g# <Plug>(asterisk-gz#)
    let g:asterisk#keeppos = 1
else
    nnoremap * *N
    nnoremap # g*N
endif

nmap [:space:]s #:%s/<C-r>//<C-r>//gc<M-b><M-b><M-b>
vmap [:space:]s #:%s/<C-r>//<C-r>//gc<M-b><M-b><M-b>

" function! s:RegistSearchWord()
"     silent normal yiw
"     let @/ = '\<'.@".'\>'
" endfunction
"
" command! -range RegistSearchWord :call s:RegistSearchWord()
" nnoremap <silent> * :RegistSearchWord<CR>

" /で検索しても、?で検索してもnで前方検索、Nで後方検索
" http://deris.hatenablog.jp/entry/2014/05/20/235807
nnoremap <expr> n <SID>search_forward_p() ? 'n' : 'N'
nnoremap <expr> N <SID>search_forward_p() ? 'N' : 'n'
vnoremap <expr> n <SID>search_forward_p() ? 'n' : 'N'
vnoremap <expr> N <SID>search_forward_p() ? 'N' : 'n'

function! s:search_forward_p()
    return exists('v:searchforward') ? v:searchforward : 1
endfunction

" バックスラッシュやクエスチョンを状況に合わせ自動的にエスケープ
cnoremap <expr> /  getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ?  getcmdtype() == '?' ? '\?' : '?'
cnoremap <expr> \/ getcmdtype() == '/' ? '/'  : '\/'
cnoremap <expr> \? getcmdtype() == '?' ? '?'  : '\?'

"ヴィビュアルモードで選択した範囲だけ検索
xnoremap <Leader>/ <ESC>/\%V
xnoremap <Leader>? <ESC>?\%V

" <C-n>, <C-p> {{{1
" ============================================================================
if IsInstalled('yankround.vim') && IsInstalled('QuickFixCurrentNumber')
    nmap <expr><C-P> yankround#is_active() ? "\<Plug>(yankround-prev)" : "\<Plug>(QuickFixCurrentNumberQPrev)"
    nmap <expr><C-N> yankround#is_active() ? "\<Plug>(yankround-next)" : "\<Plug>(QuickFixCurrentNumberQNext)"
endif

" emacs keybind {{{1
" ============================================================================
" vim/gvim挿入モードのキーを若干Emacs風味にカスタマイズ - fudisti
" - https://sites.google.com/site/fudist/Home/vim-nihongo-ban/tips/vim-key-emacs
" コマンドラインモードはhttps://github.com/tmsanrinsha/vim-emacscommandline 参照
inoremap <C-b> <Left>
inoremap <C-f> <Right>

" inoremap <C-n> <Down>
" inoremap <C-p> <Up>
inoremap <M-n> <Down>
inoremap <M-p> <Up>

inoremap <C-a> <Esc>I
inoremap <C-e> <End>

if !IsInstalled('lexima.vim')
    inoremap <C-d> <Del>
    " inoremap <expr> <C-d> "\<C-g>u".(col('.') == col('$') ? '<Esc>^y$A<Space>=<Space><C-r>=<C-r>"<CR>' : '<Del>')
endif

" 元々のi_CTRL-Dは左にインデントする処理。
" 右にインデントするのがi_CTRL-Tなので<M-t>に設定する
inoremap <M-t> <C-d>

"カーソル位置から後の単語を削除
inoremap <silent> <M-d> <C-g>u<C-r>=MyDeleteWord()<CR>

""""""""""""""""""""""""""""""
"カーソル以降の単語削除
""""""""""""""""""""""""""""""
function! MyDeleteWord()
  if col('.') == col('$')
    return ''
  endif
  let save_cursor = getpos('.')
  silent exec 'normal! wge'
  if save_cursor[1] != line('.') || (save_cursor[2] > col('.'))
    call setpos('.', save_cursor)
    return MyExecExCommand('normal! dw', 'onemore')
  endif
  silent exec 'normal! v'
  call setpos('.', save_cursor)
  return MyExecExCommand('normal! d')
endfunction

""""""""""""""""""""""""""""""
"IMEの状態とカーソル位置保存のため<C-r>を使用してコマンドを実行。
""""""""""""""""""""""""""""""
function! MyExecExCommand(cmd, ...)
  let saved_ve = &virtualedit
  let index = 1
  while index <= a:0
    if a:{index} ==# 'onemore'
      silent setlocal virtualedit+=onemore
    endif
    let index = index + 1
  endwhile

  silent exec a:cmd
  if a:0 > 0
    silent exec 'setlocal virtualedit='.saved_ve
  endif
  return ''
endfunction

" neocomplcacheにて設定
" inoremap <C-h> <BS>

if !IsInstalled('neosnippet.vim')
    inoremap <C-k> <C-o>D
endif
inoremap <C-_> <C-o>u

" * があるときに<Tab>を打つと右にインデントしたい
" →insertモードで<C-t>打つと右にインデントできる
" function! s:MyIndent()
"     if match(getline('.'), '^\s*\*') >= 0
"         normal! >>A
"     else
"         execute "normal! i\<Tab>"
"     endif
" endfunction
" command! MyIndent call s:MyIndent()

" inoremap <Tab> <C-o>:MyIndent<CR>

" インデントしない改行
" [vim-jp » Hack #57: 空行を挿入する](http://vim-jp.org/vim-users-jp/2009/08/15/Hack-57.html)
" [空行を挿入する+α - derisの日記](http://deris.hatenablog.jp/entry/20130404/1365086716)
nnoremap <silent><C-j> :<C-u>call append(line('.'), '')<CR>j

imap <silent><C-j> <End><CR>

" syntax highlight, colorscheme {{{1
" ============================================================================
" 256色を使えるようにする
set t_Co=256

" シンタックスハイライトを効かせる
" markdownのファイルを開いた後にsytax enableをするとハイライトがおかしくなる。
" vimrcをリローダブルにするため、すでにシンタックスが効いているなら、syntax enableをしない
if !exists('g:syntax_on')
    syntax enable
endif

if IsInstalled('my_molokai')
    " let g:molokai_original = 1
    " let g:rehash256 = 1
    colorscheme molokai-customized
endif

" let g:solarized_termcolors=256
let g:solarized_contrast = 'high'
" colorscheme solarized

" 16色の色見本
" :so $VIMRUNTIME/syntax/colortest.vim 
" 新しいウィンドウを開き、全てのハイライトグループ名をそれぞれの色を使って表示
" :so $VIMRUNTIME/syntax/hitest.vim

" カーソル以下のカラースキームの情報の取得 {{{2
" ----------------------------------------------------------------------------
" http://cohama.hateblo.jp/entry/2013/08/11/020849
function! s:get_syn_id(transparent)
    let l:synid = synID(line('.'), col('.'), 1)
    if a:transparent
        return synIDtrans(l:synid)
    else
        return l:synid
    endif
endfunction
function! s:get_syn_attr(synid)
    let l:name = synIDattr(a:synid, 'name')
    let l:ctermfg = synIDattr(a:synid, 'fg', 'cterm')
    let l:ctermbg = synIDattr(a:synid, 'bg', 'cterm')
    let l:guifg = synIDattr(a:synid, 'fg', 'gui')
    let l:guibg = synIDattr(a:synid, 'bg', 'gui')
    return {
    \   'name': l:name,
    \   'ctermfg': l:ctermfg,
    \   'ctermbg': l:ctermbg,
    \   'guifg': l:guifg,
    \   'guibg': l:guibg
    \}
endfunction
function! s:get_syn_info()
    let l:baseSyn = s:get_syn_attr(s:get_syn_id(0))
    echo 'name: ' . l:baseSyn.name .
    \   ' ctermfg: ' . l:baseSyn.ctermfg .
    \   ' ctermbg: ' . l:baseSyn.ctermbg .
    \   ' guifg: '   . l:baseSyn.guifg .
    \   ' guibg: '   . l:baseSyn.guibg
    let l:linkedSyn = s:get_syn_attr(s:get_syn_id(1))
    echo 'link to'
    echo 'name: ' . l:linkedSyn.name .
    \ ' ctermfg: ' . l:linkedSyn.ctermfg .
    \ ' ctermbg: ' . l:linkedSyn.ctermbg .
    \ ' guifg: '   . l:linkedSyn.guifg .
    \ ' guibg: '   . l:linkedSyn.guibg
endfunction
command! SyntaxInfo call s:get_syn_info()
" }}}
" Rgb2xterm {{{2
" ----------------------------------------------------------------------------
" true color(#FF0000など)を一番近い256色の番号に変換する
" http://d.hatena.ne.jp/y_yanbe/20080611
"" the 6 value iterations in the xterm color cube
let s:valuerange = [ 0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF ]

"" 16 basic colors
let s:basic16 = [ [ 0x00, 0x00, 0x00 ], [ 0xCD, 0x00, 0x00 ], [ 0x00, 0xCD, 0x00 ], [ 0xCD, 0xCD, 0x00 ], [ 0x00, 0x00, 0xEE ], [ 0xCD, 0x00, 0xCD ], [ 0x00, 0xCD, 0xCD ], [ 0xE5, 0xE5, 0xE5 ], [ 0x7F, 0x7F, 0x7F ], [ 0xFF, 0x00, 0x00 ], [ 0x00, 0xFF, 0x00 ], [ 0xFF, 0xFF, 0x00 ], [ 0x5C, 0x5C, 0xFF ], [ 0xFF, 0x00, 0xFF ], [ 0x00, 0xFF, 0xFF ], [ 0xFF, 0xFF, 0xFF ] ]

function! s:xterm2rgb(color)
    " 16 basic colors
    let l:r=0
    let l:g=0
    let l:b=0
    if a:color<16
        let l:r = s:basic16[a:color][0]
        let l:g = s:basic16[a:color][1]
        let l:b = s:basic16[a:color][2]
    endif

    " color cube color
    if a:color>=16 && a:color<=232
        let l:color=a:color-16
        let l:r = s:valuerange[(l:color/36)%6]
        let l:g = s:valuerange[(l:color/6)%6]
        let l:b = s:valuerange[l:color%6]
    endif

    " gray tone
    if a:color>=233 && a:color<=253
        let l:r=8+(a:color-232)*0x0a
        let l:g=l:r
        let l:b=l:r
    endif
    let l:rgb=[l:r,l:g,l:b]
    return l:rgb
endfunction

" selects the nearest xterm color for a rgb value like #FF0000
function! s:rgb2xterm(color)
    let s:colortable=[]
    for l:c in range(0, 254)
        let l:color = s:xterm2rgb(l:c)
        call add(s:colortable, l:color)
    endfor

    let l:best_match=0
    let l:smallest_distance = 10000000000
    let l:r = eval('0x'.a:color[0].a:color[1])
    let l:g = eval('0x'.a:color[2].a:color[3])
    let l:b = eval('0x'.a:color[4].a:color[5])
    for l:c in range(0,254)
        let l:d = pow(s:colortable[l:c][0] - l:r, 2) + pow(s:colortable[l:c][1] - l:g, 2) + pow(s:colortable[l:c][2] - l:b, 2)
        if l:d < l:smallest_distance
            let l:smallest_distance = l:d
            let l:best_match = l:c
        endif
    endfor
    return l:best_match
endfunction
command! -nargs=1 Rgb2xterm echo s:rgb2xterm(<f-args>)
command! -nargs=1 Xterm2rgb echo s:xterm2rgb(<f-args>)

" その他の参考になりそうな変換
" [xterm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Xterm)
" [lightline.vimをカスタマイズする - cafegale](http://leafcage.hateblo.jp/entry/2013/10/21/lightlinevim-customize)
" .vim/bundle/lightline.vim/autoload/lightline/colorscheme.vim の変換や
" [vim-coloresque/vim-coloresque.vim at master · gorodinskiy/vim-coloresque](https://github.com/gorodinskiy/vim-coloresque/blob/master/after/syntax/css/vim-coloresque.vim)

" syntaxの遡る行数を上げる {{{2
" ----------------------------------------------------------------------------
" グローバルな設定では無いらしく、autocmd FileTypeで設定
" autocmd MyVimrc FileType html,markdown,php syntax sync minlines=500 maxlines=5000
autocmd MyVimrc FileType markdown syntax sync minlines=500 maxlines=5000
" :syntax syncでminmalとmaximalの値を確認できる
" 参考
" [Big Sky :: 意外と知られていないvimのtips(開発に便利な設定)](http://mattn.kaoriya.net/software/vim/20070821175457.htm)
" :h :syn-sync-maxlines

" :h doxygen-syntax
" let g:load_dosygen_syntax=1

" cursorlineは重いので必要なときだけ有効にする {{{2
" ----------------------------------------------------------------------------
" 'cursorline' を必要な時にだけ有効にする - 永遠に未完成
" <http://d.hatena.ne.jp/thinca/20090530/1243615055>
set updatetime=100
" updatetimeミリ秒ごとにswapファイルが作られないようにswapファイルの設定を消す
" あとswapファイルが度々作られて、表示がでるのがいやなのでnoswapにする
set noswapfile

" CursorHold を使って、setlocal cursorlineをするとj, kで短い行に行ったあと長い行にいったとき
" にカラムが戻らないのでコメントアウト
" augroup MyVimrc
"     " autocmd CursorMoved,CursorMovedI * call s:auto_cursorline('CursorMoved')
"     " autocmd CursorHold,CursorHoldI * call s:auto_cursorline('CursorHold')
"
"     autocmd CursorMoved * call s:auto_cursorline('CursorMoved')
"     autocmd CursorHold  * call s:auto_cursorline('CursorHold')
"     autocmd InsertEnter * call s:auto_cursorline('InsertEnter')
"     autocmd WinEnter    * call s:auto_cursorline('WinEnter')
"     autocmd WinLeave    * call s:auto_cursorline('WinLeave')
" augroup END
"
" let s:cursorline_lock = 0
" function! s:auto_cursorline(event)
"     if &filetype ==# 'qf' || &diff
"         if &cursorline
"             setlocal nocursorline
"         endif
"         return
"     endif
"
"     if a:event ==# 'WinEnter'
"         setlocal cursorline
"         let s:cursorline_lock = 2
"     elseif a:event ==# 'WinLeave'
"         setlocal cursorline
"     elseif a:event ==# 'CursorMoved'
"         if s:cursorline_lock
"             if s:cursorline_lock > 1
"                 let s:cursorline_lock = 1
"             else
"                 setlocal nocursorline
"                 let s:cursorline_lock = 0
"             endif
"         endif
"     elseif a:event ==# 'CursorHold'
"         setlocal cursorline
"         let s:cursorline_lock = 1
"     elseif a:event ==# 'InsertEnter'
"         setlocal nocursorline
"     endif
" endfunction

set cursorline

autocmd MyVimrc WinEnter *
\   if &filetype ==# 'qf' || &diff
\|      setlocal nocursorline
\|  else
\|      setlocal cursorline
\|  endif



" diff {{{1
" ============================================================================
set diffopt+=vertical
nnoremap [:diff:] <Nop>
nmap [:space:]d [:diff:]
xnoremap [:diff:] <Nop>
xmap [:space:]d [:diff:]
nnoremap [:diff:]t :diffthis<CR>
nnoremap [:diff:]u :diffupdate<CR>
nnoremap [:diff:]o :diffoff<CR>
nnoremap [:diff:]T :windo diffthis<CR>
nnoremap [:diff:]O :windo diffoff<CR>
nnoremap [:diff:]s :vertical diffsplit<space>
nnoremap [:diff:]w :set diffopt+=iwhite<CR>
nnoremap [:diff:]W :set diffopt-=iwhite<CR>
nnoremap [:diff:]p :<C-u>%diffput<CR>
nnoremap [:diff:]g :<C-u>%diffget<CR>
xnoremap [:diff:]p :diffput<CR>
xnoremap [:diff:]g :diffget<CR>

" vimdiffでより賢いアルゴリズム (patience, histogram) を使う - Qiita {{{2
" ----------------------------------------------------------------------------
" http://qiita.com/takaakikasai/items/3d4f8a4867364a46dfa3
" https://github.com/fumiyas/home-commands/blob/master/git-diff-normal
let s:git_diff_normal='git-diff-normal'
" let s:git_diff_normal_opts=["--diff-algorithm=histogram"]
" gitのバージョンが1.7だと--diff-algorithmが使えなかった
let s:git_diff_normal_opts=['--patience']

function! GitDiffNormal()
    let args=[s:git_diff_normal]
    if &diffopt =~# 'iwhite'
        call add(args, '--ignore-all-space')
    endif
    call extend(args, s:git_diff_normal_opts)
    call extend(args, [v:fname_in, v:fname_new])
    let cmd=join(args, ' ') . '>' . v:fname_out
    call system(cmd)
endfunction

autocmd MyVimrc FilterWritePre *
\   if &diff && !exists('g:my_check_diff')
\|      if executable(s:git_diff_normal) && executable('git')
\|          set diffexpr=GitDiffNormal()
\|      endif
\|      let g:my_check_diff = 1
\|  endif

" diffchar.vim {{{2
" ----------------------------------------------------------------------------
" vimdiffで単語単位の差分表示: diffchar.vimが超便利 - Qiita
" http://qiita.com/takaakikasai/items/0d617b6e0aed490dff35
if IsInstalled('diffchar.vim')
    let g:DiffUnit='Word3'
    " vimdiffで起動した時にdiffcharを有効にする
    " diffupdateした時にうまくいかない気がするのでコメントアウト
    " if &diff
    "     autocmd MyVimrc VimEnter * %SDChar
    " endif

    " Gdiff使った時に自動的にdiffcharを有効にしたかったが、エラーが出るため断念
    " autocmd MyVimrc BufEnter *
    " \   if &diff |
    " \       execute '%SDChar' |
    " \   endif
endif

" local {{{1
" ============================================================================
call SourceRc('local.vim')
